<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="mhw.20190606134904.1"><vh>@path arcplus</vh>
<v t="mhw.20190606134949.1"><vh>@clean arcplus.py</vh>
<v t="mhw.20190925103251.3"><vh>Declarations (arcplus.py)</vh></v>
<v t="mhw.20190925103251.4"><vh>listAllFeatureClasses (arcplus.py)</vh></v>
<v t="mhw.20190925103251.5"><vh>layer_from_selected (arcplus.py)</vh></v>
</v>
<v t="mhw.20190708130736.1"><vh>@clean gpcodes.py</vh>
<v t="mhw.20190925103251.6"><vh>Declarations (gpcodes.py)</vh></v>
</v>
<v t="mhw.20190606135052.12"><vh>@clean profile-arcpy-listFC.py</vh>
<v t="mhw.20190925103251.7"><vh>Declarations (profile-arcpy-listFC.py)</vh></v>
<v t="mhw.20190925103251.8"><vh>arcpy_listFC (profile-arcpy-listFC.py)</vh></v>
</v>
<v t="mhw.20190606135052.9"><vh>@clean profile-arcplus-listAllFC.py</vh>
<v t="mhw.20190925103251.9"><vh>Declarations (profile-arcplus-listAllFC.py)</vh></v>
<v t="mhw.20190925103251.10"><vh>listAllFeatureClasses (profile-arcplus-listAllFC.py)</vh></v>
</v>
<v t="mhw.20190606135052.7"><vh>@clean interpolate_z_between.py</vh>
<v t="mhw.20190925103251.11"><vh>Declarations (interpolate_z_between.py)</vh></v>
</v>
<v t="mhw.20190606135052.2"><vh>@clean count-vertices.py</vh>
<v t="mhw.20190925103251.12"><vh>Declarations (count-vertices.py)</vh></v>
<v t="mhw.20190925103251.13"><vh>count_vertices (count-vertices.py)</vh></v>
<v t="mhw.20190925103251.14"><vh>print_report (count-vertices.py)</vh></v>
<v t="mhw.20190925103251.15"><vh>get_feature_classes (count-vertices.py)</vh></v>
</v>
<v t="maphew.20120201135209.1853"><vh>@file AttributedMultiRingBuffer.py</vh></v>
</v>
<v t="maphew.20140522093157.1505"><vh>@path ArcToolbox/Scripts</vh>
<v t="mhw.20190925103922.1"><vh>@clean save-layers-my-credentials.py</vh>
<v t="mhw.20190925103950.1"><vh>Declarations (save-layers-my-credentials.py)</vh></v>
<v t="mhw.20190925103950.2"><vh>get_filenames (save-layers-my-credentials.py)</vh></v>
</v>
<v t="mhw.20190606135214.14"><vh>@clean ungenerate.py</vh>
<v t="mhw.20190925103252.1"><vh>Declarations (ungenerate.py)</vh></v>
<v t="mhw.20190925103252.2"><vh>get_sepchar (ungenerate.py)</vh></v>
<v t="mhw.20190925103252.3"><vh>validate_id (ungenerate.py)</vh></v>
</v>
<v t="mhw.20190606135214.11"><vh>@clean TableToCSV.py</vh>
<v t="mhw.20190925103252.4"><vh>Declarations (TableToCSV.py)</vh></v>
<v t="mhw.20190925103252.5"><vh>table2csv (TableToCSV.py)</vh></v>
</v>
<v t="mhw.20190606135214.9"><vh>@clean symbol_from_table.py</vh>
<v t="mhw.20190925103252.6"><vh>Declarations (symbol_from_table.py)</vh></v>
</v>
<v t="mhw.20190606135214.7"><vh>@clean shp2gen.py</vh>
<v t="mhw.20190925103252.7"><vh>Declarations (shp2gen.py)</vh></v>
</v>
<v t="mhw.20190606135214.5"><vh>@clean set_legend_descriptions.py</vh>
<v t="mhw.20190925103252.8"><vh>Declarations (set_legend_descriptions.py)</vh></v>
</v>
<v t="mhw.20190606135214.1"><vh>@clean sdeconn.py</vh>
<v t="mhw.20190925103252.9"><vh>Declarations (sdeconn.py)</vh></v>
<v t="mhw.20190925103252.10"><vh>connect (sdeconn.py)</vh></v>
<v t="mhw.20190925103252.11"><vh>get_profile_info (sdeconn.py)</vh></v>
<v t="mhw.20190925103252.12"><vh>connect_filename (sdeconn.py)</vh></v>
<v t="mhw.20190925103252.13"><vh>listFcsInGDB (sdeconn.py)</vh></v>
</v>
<v t="mhw.20190606135213.47"><vh>@clean metadata_batch_upgrade.py</vh>
<v t="mhw.20190925103252.14"><vh>Declarations (metadata_batch_upgrade.py)</vh></v>
<v t="mhw.20190925103252.15"><vh>main (metadata_batch_upgrade.py)</vh></v>
</v>
<v t="mhw.20190606135213.44"><vh>@clean layer_from_selected.py</vh>
<v t="mhw.20190925103252.16"><vh>Declarations (layer_from_selected.py)</vh></v>
<v t="mhw.20190925103252.17"><vh>main (layer_from_selected.py)</vh></v>
</v>
<v t="mhw.20190606135213.40"><vh>@clean interp_missing_z.py</vh>
<v t="mhw.20190925103252.18"><vh>Declarations (interp_missing_z.py)</vh></v>
<v t="mhw.20190925103252.19"><vh>showPyMessage (interp_missing_z.py)</vh></v>
<v t="mhw.20190925103252.20"><vh>main (interp_missing_z.py)</vh></v>
</v>
<v t="mhw.20190606135213.33"><vh>@clean GPXtoFeaturesXY.py</vh>
<v t="mhw.20190925103252.21"><vh>Declarations (GPXtoFeaturesXY.py)</vh></v>
<v t="mhw.20190925103252.22"><vh>gpxToPoints (GPXtoFeaturesXY.py)</vh></v>
<v t="mhw.20190925103252.23"><vh>class classGPXPoint(object)</vh>
<v t="mhw.20190925103252.24"><vh>classGPXPoint(object).__init__</vh></v>
<v t="mhw.20190925103252.25"><vh>classGPXPoint(object).asPoint</vh></v>
</v>
<v t="mhw.20190925103252.26"><vh>GeneratePointFromXML (GPXtoFeaturesXY.py)</vh></v>
</v>
<v t="mhw.20190606135213.31"><vh>@clean filter-dissolve.py</vh>
<v t="mhw.20190925103252.27"><vh>Declarations (filter-dissolve.py)</vh></v>
</v>
<v t="mhw.20190606135213.26"><vh>@clean FeaturesToGPX.py</vh>
<v t="mhw.20190925103252.28"><vh>Declarations (FeaturesToGPX.py)</vh></v>
<v t="mhw.20190925103252.29"><vh>prettify (FeaturesToGPX.py)</vh></v>
<v t="mhw.20190925103252.30"><vh>featuresToGPX (FeaturesToGPX.py)</vh></v>
<v t="mhw.20190925103252.31"><vh>generatePointsFromFeatures (FeaturesToGPX.py)</vh></v>
</v>
<v t="mhw.20190606135213.19"><vh>@clean ExportLayerSymbolDefinitions.py</vh>
<v t="mhw.20190925103252.32"><vh>Declarations (ExportLayerSymbolDefinitions.py)</vh></v>
<v t="mhw.20190925103252.33"><vh>class LayerExtras(object)</vh></v>
<v t="mhw.20190925103252.34"><vh>class MxdExtras(dict)</vh>
<v t="mhw.20190925103252.35"><vh>MxdExtras(dict).__init__</vh></v>
<v t="mhw.20190925103252.36"><vh>MxdExtras(dict).loadMxdPath</vh></v>
<v t="mhw.20190925103252.37"><vh>MxdExtras(dict).loadMsdLayerDom</vh></v>
</v>
</v>
<v t="mhw.20190606135213.16"><vh>@clean ExportFolder2PDF.py</vh>
<v t="mhw.20190925103252.38"><vh>Declarations (ExportFolder2PDF.py)</vh></v>
<v t="mhw.20190925103252.39"><vh>exportmap (ExportFolder2PDF.py)</vh></v>
</v>
<v t="mhw.20190606135213.13"><vh>@clean export_gdb_domains.py</vh>
<v t="mhw.20190925103252.40"><vh>Declarations (export_gdb_domains.py)</vh></v>
<v t="mhw.20190925103252.41"><vh>export_domains (export_gdb_domains.py)</vh></v>
</v>
<v t="mhw.20190606135213.10"><vh>@clean ExcelSheetsToTables.py</vh>
<v t="mhw.20190925103252.42"><vh>Declarations (ExcelSheetsToTables.py)</vh></v>
<v t="mhw.20190925103252.43"><vh>importallsheets (ExcelSheetsToTables.py)</vh></v>
</v>
<v t="mhw.20190606135213.8"><vh>@clean clip_all_layers.py</vh>
<v t="mhw.20190925103252.44"><vh>Declarations (clip_all_layers.py)</vh></v>
</v>
<v t="mhw.20190606135213.6"><vh>@clean change_datasource_paths.py</vh>
<v t="mhw.20190925103252.45"><vh>Declarations (change_datasource_paths.py)</vh></v>
</v>
<v t="mhw.20190606135213.1"><vh>@clean xx-z-from-intersect-line.py</vh>
<v t="mhw.20190925103252.46"><vh>Declarations (xx-z-from-intersect-line.py)</vh></v>
<v t="mhw.20190925103252.47"><vh>read_stream (xx-z-from-intersect-line.py)</vh></v>
<v t="mhw.20190925103252.48"><vh>thing (xx-z-from-intersect-line.py)</vh></v>
<v t="mhw.20190925103252.49"><vh>main (xx-z-from-intersect-line.py)</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="maphew.20140522093157.1505"></t>
<t tx="mhw.20190606134904.1"></t>
<t tx="mhw.20190606134949.1">@others
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135052.12">@others
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135052.2">@others
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135052.7">@others
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135052.9">@others
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135213.1">@others
if __name__ == '__main__':
    #read_stream(fc_stream, fc_contour)
    thing(fc_stream, fc_contour)
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135213.10"># -*- coding: utf-8 -*-
@others
if __name__ == "__main__":
    in_excel = arcpy.GetParameterAsText(0)
    table_prefix = arcpy.GetParameterAsText(1)
    out_gdb = arcpy.GetParameterAsText(2)
    importallsheets(in_excel, table_prefix, out_gdb)
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135213.13"># -*- coding: utf-8 -*-
@others
if __name__ == "__main__":
    domains = arcpy.da.ListDomains(gdb)
    export_domains(domains)
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135213.16">@others
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135213.19"># courtesy of Micheal Jackson
# https://gis.stackexchange.com/questions/1466/using-arcpy-to-get-layer-symbology
@others
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135213.26">@others
if __name__ == "__main__":
    ''' Gather tool inputs and pass them to featuresToGPX(features, output files) '''

    inputFC = arcpy.GetParameterAsText(0)
    outGPX = arcpy.GetParameterAsText(1)
    pretty = arcpy.GetParameterAsText(2)

    featuresToGPX(inputFC, outGPX, pretty=pretty)
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135213.31"># -*- coding: utf-8 -*-
# ---------------------------------------------------------------------------
# filter-dissolve.py
# Created on: 2016-01-13 10:34:31.00000
#   (generated by ArcGIS/ModelBuilder)
# Usage: filter-dissolve &lt;Input_Features&gt; &lt;Filter_Expression&gt; &lt;Output_Features&gt; 
# Description: 
# ---------------------------------------------------------------------------

# Import arcpy module
@others
if Input_Features == '#' or not Input_Features:
    Input_Features = "D:\\p\\NHN\\yt_nhn.gdb\\Dataset\\NHN_HD_WATERBODY_2" # provide a default value if unspecified

Filter_Expression = arcpy.GetParameterAsText(1)
if Filter_Expression == '#' or not Filter_Expression:
    Filter_Expression = "lakeId1 NOT LIKE ''" # provide a default value if unspecified

Output_Features = arcpy.GetParameterAsText(2)
if Output_Features == '#' or not Output_Features:
    Output_Features = "D:\\p\\NHN\\yt_nhn.gdb\\Regions\\Named_Lakes" # provide a default value if unspecified

# Local variables:
nameId_not_empty = "arc_Named_Lakes"
Dissolve_Field_s_ = "permanency;lakeId1;lakeName1;waterDefinitionText"

# Process: Make Feature Layer
arcpy.MakeFeatureLayer_management(Input_Features, nameId_not_empty, Filter_Expression, "", "OBJECTID OBJECTID VISIBLE NONE;SHAPE SHAPE VISIBLE NONE;nid nid VISIBLE NONE;validityDate validityDate VISIBLE NONE;acquisitionTechnique acquisitionTechnique VISIBLE NONE;datasetName datasetName VISIBLE NONE;planimetricAccuracy planimetricAccuracy VISIBLE NONE;provider provider VISIBLE NONE;completelyCover completelyCover VISIBLE NONE;waterDefinition waterDefinition VISIBLE NONE;isolated isolated VISIBLE NONE;permanency permanency VISIBLE NONE;geographicalNameDB geographicalNameDB VISIBLE NONE;lakeId1 lakeId1 VISIBLE NONE;lakeId2 lakeId2 VISIBLE NONE;riverId1 riverId1 VISIBLE NONE;riverId2 riverId2 VISIBLE NONE;lakeName1 lakeName1 VISIBLE NONE;lakeName2 lakeName2 VISIBLE NONE;riverName1 riverName1 VISIBLE NONE;riverName2 riverName2 VISIBLE NONE;idDate idDate VISIBLE NONE;nameDate nameDate VISIBLE NONE;waterDefinitionText waterDefinitionText VISIBLE NONE;SHAPE_Length SHAPE_Length VISIBLE NONE;SHAPE_Area SHAPE_Area VISIBLE NONE")

# Process: Dissolve
arcpy.Dissolve_management(nameId_not_empty, Output_Features, Dissolve_Field_s_, "", "MULTI_PART", "DISSOLVE_LINES")

@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135213.33">@others
if __name__ == "__main__":
    ''' Gather tool inputs and pass them to gpxToPoints(file, outputFC) '''

    gpx = arcpy.GetParameterAsText(0)
    outFC = arcpy.GetParameterAsText(1)
    gpxToPoints(gpx, outFC)
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135213.40">@others
if __name__ == '__main__':
    main()
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135213.44">@others
if __name__ == "__main__":
    ''' Gather tool inputs and pass them to gpxToPoints(file, outputFC) '''
    layer = arcpy.GetParameterAsText(0)
    main(layer)
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135213.47">@others
if __name__ == "__main__":
    ''' Gather tool inputs and pass them to gpxToPoints(file, outputFC) '''

    gdb = arcpy.GetParameterAsText(0)
    main(gdb)
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135213.6">@others
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135213.8">@others
if not mxd:
    mxd = arcpy.mapping.MapDocument("CURRENT")
else:
    mxd = arcpy.mapping.MapDocument(mxd)

for lyr in arcpy.mapping.ListLayers(mxd):
    if lyr.isBroken:
        arcpy.AddMessage('"%s"\t skipping broken layer' % lyr)
        continue
    elif not lyr.isGroupLayer:
        arcpy.AddMessage('"%s"\t Clipping...' % lyr)
        out_layer = os.path.join(out_gdb, lyr.name)
        if lyr.isFeatureLayer:
            arcpy.Clip_analysis(lyr, clip_layer, out_layer)
        elif lyr.isRasterLayer:
            arcpy.Clip_management(lyr, '#', out_layer, clip_layer, '#', 'ClippingGeometry')
        else:
            arcpy.AddMessage('"%s" skipping, not a Feature or Raster layer')
    else:
        if not lyr.isGroupLayer:
            arcpy.AddMessage('"%s"\t unknown layer type, dont know what to do with it.' % lyr)
            
            
print arcpy.GetMessages()
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135214.1">@others
if __name__ == '__main__':
    print "started main"
    platform = arcpy.GetParameterAsText(0)
    database = arcpy.GetParameterAsText(1)
    server = arcpy.GetParameterAsText(2)
    username = arcpy.GetParameterAsText(3)
    password = arcpy.GetParameterAsText(4)
    version = arcpy.GetParameterAsText(5)

    if not platform:
        platform = 'Oracle'
    if not version:
        version = "SDE.DEFAULT"

    profile = get_profile_info()

    print "make connection file"
    sde = connect(platform, database, server, username, password, version)

    print sde
    arcpy.env.workspace = sde
    print arcpy.env.workspace

    for fc in listFcsInGDB():
        print fc

    print arcpy.GetMessages()


@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135214.11">@others
if __name__ == "__main__":
    ''' Gather tool inputs and pass them to main function '''

    table = arcpy.GetParameterAsText(0)
    outfile = arcpy.GetParameterAsText(1)
    table2csv(table, outfile)
    
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135214.14">@others
if len(sys.argv) &lt; 4: raise Exception, msgNotEnoughParams
inputFC = sys.argv[1]
outFile = open(sys.argv[2], "w")

#optional parameters
sepchar = get_sepchar(decimalchar)

arcpy.AddMessage('\n--- {0}'.format(inputFC))
inDesc = arcpy.Describe(inputFC)
id_field = validate_id(id_fieldname, inDesc)

inRows = arcpy.SearchCursor(inputFC, where_clause)
inRow = inRows.next()

## This confuses ANUDEM, leave out for now.
##outFile.write("//{0}\n".format(inDesc.ShapeType))

while inRow:
    feat = inRow.getValue(inDesc.ShapeFieldName)
    if inDesc.ShapeType.lower() == "point":
        pnt = feat.getPart()
##        outLine = "{0},{1},{2},{3},{4}\n".format(inRow.getValue(id_field), pnt.X, pnt.Y, pnt.Z, pnt.M)
        outLine = "{0},{1},{2}\n".format(inRow.getValue(id_field), pnt.X, pnt.Y)
        if sepchar == "": outFile.write(outLine)
        else: outFile.write(outLine.replace(".", sepchar))

    elif inDesc.ShapeType.lower() == "multipoint":
        partnum = 0
        partcount = feat.partCount
        outFile.write("{0},{1}\n".format(inRow.getValue(id_field), str(partnum))) # begin new feature
        while partnum &lt; partcount:
            pnt = feat.getPart(partnum)
##            outLine = "{0},{1},{2},{3},{4}\n".format(partnum, pnt.X, pnt.Y, pnt.Z, pnt.M)
            outLine = "{0},{1},{2}\n".format(partnum, pnt.X, pnt.Y)
            if sepchar == "": outFile.write(outLine)
            else: outFile.write(outLine.replace(".", sepchar))
            partnum += 1
    else:
        partnum = 0
        partcount = feat.partCount
        while partnum &lt; partcount:
##            outFile.write("{0},{1}\n".format(inRow.getValue(id_field), str(partnum))) # begin new feature
            outFile.write("{0}\n".format(inRow.getValue(id_field))) # begin new feature
            part = feat.getPart(partnum)
            part.reset()
            pnt = part.next()
            pnt_count = 0
            while pnt:
##                outLine = "{0},{1},{2},{3}\n".format(pnt.X, pnt.Y, pnt.Z, pnt.M)
                outLine = "{0},{1}\n".format(pnt.X, pnt.Y)
                if sepchar == "": outFile.write(outLine)
                else: outFile.write(outLine.replace(".", sepchar))
                pnt = part.next()
                pnt_count += 1
                if not pnt:
                    pnt = part.next()
                    if pnt:
##                        outFile.write("InteriorRing\n%s\n" % partnum)
                        outFile.write("END\n") # end feature part
                        outFile.write("{0},{1}\n".format(inRow.getValue(id_field), str(pnt_count))) # begin new feature part
            outFile.write("END\n") # end feature
            partnum += 1
    inRow = inRows.next()
outFile.write("END\n")
outFile.flush()
outFile.close()
arcpy.AddMessage('Wrote {0}'.format(outFile.name))
print arcpy.GetMessages()
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135214.5">@others
if lyr.symbologyType == "UNIQUE_VALUES":

    #extract matches
    for symbol in lyr.symbology.classValues:
      desclist.append(descriptions[symbol])    
    
    # assign the descriptions
    lyr.symbology.classDescriptions = desclist


mxd.saveACopy(output_map)
del mxd
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135214.7">#!/usr/bin/env python
#
# shp2gen.py
# Convert shapefile to arcinfo generate format
#
# Author: Matthew Perry
#
@others
if __name__ == "__main__":
    try:
        inputFile = sys.argv[1];
    except:
        print " usage: shp2gen.py input.shp &gt; output.gen"
        sys.exit(1)

    # Open dataset and get layer
    ds = ogr.Open(inputFile)
    layer = ds.GetLayer()

    coords = ''
    feature = layer.GetNextFeature()
    fn = 0
    while feature is not None:
        coords = '';
        geom = feature.GetGeometryRef()
        geomtype = geom.GetGeometryType()
        if geomtype == ogr.wkbPoint:
            coords = coords + str(fn) + "," + str(geom.GetX(0)) + "," + \
                     str(geom.GetY(0)) + "\n";
        elif geomtype == ogr.wkbLineString or geomtype == ogr.wkbPolygon:
            geom = geom.GetGeometryRef(0)
            numpoints = geom.GetPointCount()
            coords = coords + str(fn) + "\n"
            for i in range(numpoints):
                coords = coords + str(geom.GetX(i)) + " " + \
                         str(geom.GetY(i)) + "\n";
            coords = coords + "END"

        feature.Destroy()
        feature = layer.GetNextFeature()
        fn = fn+1
        if coords != '':
            print coords

    print 'END'
    ds.Destroy()
@language python
@tabwidth -4
</t>
<t tx="mhw.20190606135214.9">@others
if lyr.symbologyType == "UNIQUE_VALUES":
  lyr.symbology.classValues = stateList
  lyr.symbology.showOtherValues = False

arcpy.RefreshActiveView()
arcpy.RefreshTOC()
del mxd
@language python
@tabwidth -4
</t>
<t tx="mhw.20190708130736.1">@others
@language python
@tabwidth -4
</t>
<t tx="mhw.20190925103251.10">def listAllFeatureClasses (gdb,**kwargs):
    import arcpy
    '''
    list all Feature Classes in a geodatabase or coverage recursively
    (normal listFeatureClasses does not recurse)

        import arcplus
        fcs = arcplus.listAllFeatureClasses('d:\default.gdb')
        for fc in fcs:
            print "magic happens with: ", fc

    Arcplus also adds wildcard filtering; to process only feature classes
    that start with "HD_" within feature datasets containing "Hydro"

        fcs = arcplus.listAllFeatureClasses(gdb, fd_filter='*Hydro*', fc_filter='HD_*')
    '''

    arcpy.env.workspace = gdb

    if not kwargs.has_key('fc_filter'): fc_filter = '*'
    else: fc_filter = kwargs ['fc_filter']

    if not kwargs.has_key('fd_filter'): fd_filter = '*'
    else: fd_filter = kwargs ['fd_filter']

    print 'Looking in %s for "%s" ' % (arcpy.env.workspace,fc_filter)

    fcs = []
    for fds in arcpy.ListDatasets(fd_filter,'feature') + ['']:
        for fc in arcpy.ListFeatureClasses(fc_filter,'',fds):
            #print '%s\\%s' % (fds,fc)
            fcs.append(os.path.join(fds,fc))

    return fcs

listAllFeatureClasses(r'X:\Env-dat.081\source\yt_courbe_niveau_imperial.gdb')
</t>
<t tx="mhw.20190925103251.11">'''
Interpolate missing Z values along a 3D line.

*** BROKEN ***

Adapted from @Tomek's work at
http://gis.stackexchange.com/a/18655/108
'''
from arcplus import ao

sPath = r'd:\s\test.gdb'
fcName = 'centerline'

# import arcobjects libraries
ao.GetStandaloneModules()
ao.InitStandalone()
import comtypes.gen.esriSystem as esriSystem
import comtypes.gen.esriGeoDatabase as esriGeoDatabase
import comtypes.gen.esriDataSourcesGDB as esriDataSourcesGDB

### Open the FGDB
##pWS = ao.Standalone_OpenFileGDB(gdb)

# open geodatabase and featureclass
pWSF = ao.NewObj(esriDataSourcesGDB.FileGDBWorkspaceFactory, esriGeoDatabase.IWorkspaceFactory)
pWS = pWSF.OpenFromFile(sPath, 0)
pFWS = pWS.QueryInterface(esriGeoDatabase.IFeatureWorkspace)
pFClass = pFWS.OpenFeatureClass(str(fcName))

# set update cursor on the featureclass
pFCursor = pFClass.Update(None, True)
pFeat = pFCursor.NextFeature()

# loop trough features in featureclass
while pFeat:
    print "--- Feature:", pFeat.OID
    pShape = pFeat.ShapeCopy # clone shape of current feature
    pIZ = pShape.QueryInterface(esriGeometry.IZ2) #set IZ interface on the data - allow for interpolation of the Z value
    IPointCollection = pShape.QueryInterface(esriGeometry.IPointCollection) # set IPointCollection interface on the data - allow for points manipulation within the point collection
    IPoint = ao.NewObj(esriGeometry.Point, esriGeometry.IPoint) # create Point object with IPoint interface
    pStart = 0 # set pStart parameter to index[0]

# loop trough IPointCollection within the polyline, find pStart and pEnd point within the polyline for IZ.InterpolateZsBetween
    for i in range(IPointCollection.PointCount):
        Point = IPointCollection.QueryPoint(i, IPoint) # query for point within the IPointCollection at index i and insert it in to IPoint

# selection of the pStart and pEnd properties based on points Z value and interpolation of the vertexes within the polyline
        if i==0: # skip value at index[0]
##            pass
            print '\tSkipping point:', i
            continue
        elif IPoint.Z != 0: # assign pEnd and pStart if Z value of the point (vertex) is larger than 0.01 (0.01 not 0 as 0 in arcgis is returned in python as 4.54747350886e-013)
            pEnd = i
            pIZ.InterpolateZsBetween(0,pStart,0,pEnd) # program assumes that is dealing with single part polylines
            pFeat.Shape = pIZ
            pFCursor.UpdateFeature(pFeat)
            pStart = pEnd
    pFeat = pFCursor.NextFeature()
</t>
<t tx="mhw.20190925103251.12">import os
import arcpy

workspace = arcpy.GetParameterAsText(0)
if not workspace:
    workspace = r'Z:\V5\ENV_250k.gdb\admin_env'

</t>
<t tx="mhw.20190925103251.13">def count_vertices(fc, table):
    '''Count vertices in Feature Class, insert to dictionary named "table"'''
    # Adapted from Alex Tereshenkov (@alex-tereshenkov)
    # https://gis.stackexchange.com/questions/84796/extracting-number-of-vertices-in-each-polygon
    features = [feature[0] for feature in arcpy.da.SearchCursor(fc,"SHAPE@")]
    count_vertices = sum([f.pointCount-f.partCount for f in features])
    table[fc] = count_vertices

</t>
<t tx="mhw.20190925103251.14">def print_report(table):
    '''Print dictionary as table
    (Naive, paths longer than X characters mess up the table)'''
    print "{:60}\t:\t{:&gt;12}".format('-' * 60, '-' * 12)
    print "{:60}\t:\t{:&gt;12}".format('Feature Class', 'Vertices')
    print "{:60}\t:\t{:&gt;12}".format('-' * 60, '-' * 12)
    for k,v in table.items():
        print "{:60}\t:\t{:&gt;12,}".format(k,v)    


</t>
<t tx="mhw.20190925103251.15">def get_feature_classes(workspace):
    '''Return list of all feature classes under Workspace (recursive)'''
    # https://gis.stackexchange.com/questions/5893/listing-all-feature-classes-in-file-geodatabase-including-within-feature-datase
    feature_classes = []
    walk = arcpy.da.Walk(workspace, datatype="FeatureClass")
    print 'Finding feature classes in', workspace
    for dirpath, dirnames, filenames in walk:
        for filename in filenames:
            feature_classes.append(os.path.join(dirpath, filename))
    return feature_classes


table = {}
for fc in get_feature_classes(workspace):
    print 'Counting', fc
    count_vertices(fc,table)

print_report(table)
</t>
<t tx="mhw.20190925103251.3">'''
Module:  arcplus
Source:  arcplus.py
Author:  Matt.Wilkie@gov.yk.ca
License: X/MIT, (c) 2014 Environment Yukon

Functions missing from regular ol' arcpy module


Place with your other code or PYTHONPATH and then:

    import arcplus
    fcs = arcplus.cool_extra_function(...)
    for fc in fcs:
        print "magic happens with: ", fc

(there is only one extra function at the moment... ;-)
'''

import os

</t>
<t tx="mhw.20190925103251.4">def listAllFeatureClasses (gdb,**kwargs):
    import arcpy
    '''
    list all Feature Classes in a geodatabase or coverage recursively
    (normal listFeatureClasses does not recurse)

        import arcplus
        fcs = arcplus.listAllFeatureClasses('d:\default.gdb')
        for fc in fcs:
            print "magic happens with: ", fc

    Arcplus also adds wildcard filtering; to process only feature classes
    that start with "HD_" within feature datasets containing "Hydro"

        fcs = arcplus.listAllFeatureClasses(gdb, fd_filter='*Hydro*', fc_filter='HD_*')
    '''

    arcpy.env.workspace = gdb

    if not kwargs.has_key('fc_filter'): fc_filter = '*'
    else: fc_filter = kwargs ['fc_filter']

    if not kwargs.has_key('fd_filter'): fd_filter = '*'
    else: fd_filter = kwargs ['fd_filter']

    print 'Looking in %s for "%s" ' % (arcpy.env.workspace,fc_filter)

    fcs = []
    for fds in arcpy.ListDatasets(fd_filter,'feature') + ['']:
        for fc in arcpy.ListFeatureClasses(fc_filter,'',fds):
            #print '%s\\%s' % (fds,fc)
            fcs.append(os.path.join(fds,fc))

    return fcs

</t>
<t tx="mhw.20190925103251.5">def layer_from_selected(layer):
    ''' Create in-memory layer using only selected features of the input layer.

        Basically this is to replicate the functionality of "{Layer} &gt;&gt; r-click &gt;&gt; Selection &gt;&gt; Create Layer from Selected Features" in a manner that can used in a python script.

        Arguments:  Layer with selected features

    Adapted from @Pete
    http://gis.stackexchange.com/questions/63717/use-a-selection-of-features-in-arcmap-in-python-script/63743#63743
    '''
    import arcpy
    arcpy.env.workspace = "in_memory"
    results_layer = layer + "_selection"
    #this will create a new feature class from the selected features but will do it In Memory
    arcpy.CopyFeatures_management(layer, results_layer)
    #Now do all the other stuff you want like convert it to a layer and work with it
    arcpy.MakeFeatureLayer_management(results_layer)
    return


</t>
<t tx="mhw.20190925103251.6">''' Generate list of possible geoprocessing error codes. These error codes are
   not documented in the help anymore so Curtis wrote a script to make a list.
   Initial version: 2019-Jul-05, Curtis Price &lt;cprice@usgs.gov&gt;
'''
import sys
import arcpy

# start code to fetch
try:
  n = int(sys.argv[1])
except IndexError:
  print('''Usage: gpcodes [start number] {optional end number}\n''')
  sys.exit()

# optional end code to fetch
try:
  nn = int(sys.argv[2])
except IndexError:
  nn = n # default to start number

nn += 1 # increment by 1 so we return the final code as well

for k in range(n,nn):
  try:
    dsc = arcpy.GetIDMessage(k)
    if dsc:
        print("{:6d}\t{}".format(k, dsc))
  except:
    pass
</t>
<t tx="mhw.20190925103251.7">import arcpy

#gdb = r'X:\Env-dat.081\source\yt_courbe_niveau_imperial.gdb'
gdb = r'D:\s\yt_courbe_niveau_imperial.gdb'


</t>
<t tx="mhw.20190925103251.8">def arcpy_listFC(gdb):
    arcpy.env.workspace = gdb
    print 'Looking in "%s" ' % arcpy.env.workspace
    fcs = arcpy.ListFeatureClasses()
    return fcs

fcs = arcpy_listFC(gdb)
print 'Feature classes found: %s' % len(fcs)
</t>
<t tx="mhw.20190925103251.9">import os

</t>
<t tx="mhw.20190925103252.1">''' ungenerate.py - write features to ArcInfo GENERATE text file format.

Arguments:
    - input feature class
    - output file name
    - decimal separator character (comma, period, system locale)
    - field to use for ID of each feature (optional)

Matt.Wilkie@gov.yk.ca, 2015-Feb-13

Tested with ArcGIS 10.3.

Adapted from "WriteFeaturesFromTextFile.py" in the Samples Toolbox distributed
by Environmental Systems Research Institute Inc. (Esri) in ArcGIS 9.x.
http://webhelp.esri.com/arcgisdesktop/9.3/index.cfm?TopicName=An_overview_of_the_Samples_toolbox
'''
import string, os, sys, locale

Usage = '''
Usage: ungenerate (in feature class) (out filename, #) (decimal separator, #) (ID field, #) {SQL where clause}

       '#' = use default
       { } = optional

    ungenerate D:\data\park_bound.shp x:\scratch\parks.gen # #
    ungenerate D:\data\park_bound.shp x:\scratch\parks.gen comma ParkName
    ungenerate D:\data\park_bound.shp x:\scratch\parks.gen comma ParkName """Type""" LIKE '%Territorial%'"
'''
if len(sys.argv) &lt; 5:
    print Usage
    sys.exit(1)

import arcpy


inputFC = arcpy.GetParameterAsText(0)
outFile = arcpy.GetParameterAsText(1)
decimalchar = arcpy.GetParameterAsText(2)
id_fieldname = arcpy.GetParameterAsText(3)

argcount = arcpy.GetArgumentCount()
if argcount &gt; 4:
    where_clause = ' '.join([arcpy.GetParameterAsText(x) for x in range(4, argcount)])
    print '\nSELECT * WHERE:\t', where_clause
else:
    where_clause = None

if outFile[-1] == '#':
    outFile = os.path.join(os.path.basename(inputFC), '.gen')

msgNotEnoughParams = "Incorrect number of input parameters."
msgUseValidDecimalPointSep = "Please use one of the valid decimal point separators."
msgFieldNotFound = 'ID field not found. Specify "#" for default or one of:'

</t>
<t tx="mhw.20190925103252.10">def connect(platform, database, server="&lt;default server&gt;", username="&lt;default user&gt;", password="&lt;default password&gt;", version="SDE.DEFAULT", Connection_File_Name):
    # Check if value entered for option
    try:
        #Usage parameters for spatial database connectdaion to upgrade
        service = "sde:{}:{}".format(platform, server)
        account_authentication = 'DATABASE_AUTH'
        version = version.upper()
        database = database.lower()

        # Check if direct connection
        if service.find(":") &lt;&gt; -1:  #This is direct connect
            ServiceConnFileName = service.replace(":", "")
            ServiceConnFileName = ServiceConnFileName.replace(";", "")
            ServiceConnFileName = ServiceConnFileName.replace("=", "")
            ServiceConnFileName = ServiceConnFileName.replace("/", "")
            ServiceConnFileName = ServiceConnFileName.replace("\\", "")
        else:
            arcpy.AddMessage("\n+++++++++")
            arcpy.AddMessage("Exiting!!")
            arcpy.AddMessage("+++++++++")
            sys.exit("\nSyntax for a direct connection in the Service parameter is required for geodatabase upgrade.")

        # Local variables
        Conn_File_NameT = server + "_" + ServiceConnFileName + "_" + database + "_" + username

        if os.environ.get("TEMP") == None:
            temp = "c:\\temp"
        else:
            temp = os.environ.get("TEMP")

        if os.environ.get("TMP") == None:
            temp = "/usr/tmp"
        else:
            temp = os.environ.get("TMP")

        #Connection_File_Name = temp + os.sep + Conn_File_NameT + ".sde"
        #if os.path.isfile(Connection_File_Name):
        #    return Connection_File_Name


        # Check for the .sde file and delete it if present
        arcpy.env.overwriteOutput=True

        # Variables defined within the script; other variable options commented out at the end of the line
        saveUserInfo = "SAVE_USERNAME" #DO_NOT_SAVE_USERNAME
        saveVersionInfo = "SAVE_VERSION" #DO_NOT_SAVE_VERSION


        print "\nCreating ArcSDE Connection File...\n"
        # Process: Create ArcSDE Connection File...
        # Usage: out_folder_path, out_name, server, service, database, account_authentication, username, password, save_username_password, version,   save_version_info
        print temp
        print Conn_File_NameT
        print server
        print service
        print database
        print account_authentication
        print username
        print password
        print saveUserInfo
        print version
        print saveVersionInfo
        arcpy.CreateArcSDEConnectionFile_management(temp,
            Conn_File_NameT,
            server,
            service,
            database,
            account_authentication,
            username,
            password,
            saveUserInfo,
            version,
            saveVersionInfo)
        for i in range(arcpy.GetMessageCount()):
            if "000565" in arcpy.GetMessage(i):   #Check if database connection was successful
                arcpy.AddReturnMessage(i)
                arcpy.AddMessage("\n+++++++++")
                arcpy.AddMessage("Exiting!!")
                arcpy.AddMessage("+++++++++\n")
                sys.exit(3)
            else:
                arcpy.AddReturnMessage(i)
                arcpy.AddMessage("+++++++++\n")
                return Connection_File_Name
    #Check if no value entered for option
    except SystemExit as e:
        print e.code
        return

</t>
<t tx="mhw.20190925103252.11">def get_profile_info():
    '''
    Kudos @Michael-Stimson https://gis.stackexchange.com/a/154572/108
    '''
    d = {}
    d['appdata'] = os.environ.get("APPDATA") # not case sensitive
    d['II']      = arcpy.GetInstallInfo()
    d['version'] = II["Version"]             # Case sensitive
    d['desktop_fld']  = "{0}\\ESRI\\Desktop{1}".format(AppData,Version)
    d['connections'] = "{}\\ArcCatalog".format(d['desktop_fld'])
    return d

</t>
<t tx="mhw.20190925103252.12">def connect_filename(profile, database, username):
    '''Return full path for connection file
     Example:
        "C:\Users\mhwilkie\AppData\Roaming\ESRI\Desktop10.6\ArcCatalog\Connection to CSWPROD (mhwilkie).sde"
    '''
    fname = '{0}\\Connection to {1} ({2}).sde'.format(
        profile['connections'],
        database,
        username)
    return fname


</t>
<t tx="mhw.20190925103252.13">def listFcsInGDB():
    ''' set your arcpy.env.workspace to a gdb before calling '''
    for fds in arcpy.ListDatasets('','feature') + ['']:
        for fc in arcpy.ListFeatureClasses('','',fds):
            yield os.path.join(arcpy.env.workspace, fds, fc)

</t>
<t tx="mhw.20190925103252.14">'''
Tool Name:   Metadata Batch Upgrade
Source Name: metadata_batch_upgrade.py
Version:     ArcGIS 10.2.2
Author:      Matt.Wilkie@gov.yk.ca
Started:     2013-May-16
License:     X/MIT, (c) 2014 Environment Yukon

Required Arguments:
         Input Geodatabase or Workspace: path to gdb or workspace

Description:
        Recursively walk through a GDB or workspace and upgrades the metadata record of any feature class found.

'''

import arcpy
import arcplus

</t>
<t tx="mhw.20190925103252.15">def main(gdb):
    fcs = arcplus.listAllFeatureClasses(gdb)
    for fc in fcs:
        print "magic happens with: ", fc
        arcpy.UpgradeMetadata_conversion(
            Source_Metadata=fc,
            Upgrade_Type="FGDC_TO_ARCGIS")
        print arcpy.GetMessages()
    

</t>
<t tx="mhw.20190925103252.16">'''
Tool Name:   Create layer from selected features
Version:     ArcGIS 10.3
Author:      Matt.Wilkie@gov.yk.ca
Started:     2015-Apr-07
License:     X/MIT, (c) 2015 Environment Yukon

Required Arguments:
         Layer with selected features

Description:
        Create in-memory layer using only selected features of the input layer. Basically this is to replicate the functionality of "{Layer} &gt;&gt; r-click &gt;&gt; Selection &gt;&gt; Create Layer from Selected Features" in a manner that can used in a python script.

Adapted from @Pete      
http://gis.stackexchange.com/questions/63717/use-a-selection-of-features-in-arcmap-in-python-script/63743#63743
'''
import arcpy
from arcpy import env

</t>
<t tx="mhw.20190925103252.17">def main(layer):
    arcpy.env.workspace = "in_memory"

    layer = "The Feature Class with the selection"
    results_layer = layer + "_selection"

    #this will create a new feature class from the selected features but will do it In Memory
    arcpy.CopyFeatures_management(layer, results_layer)

    #Now do all the other stuff you want like convert it to a layer and work with it
    arcpy.MakeFeatureLayer_management(results_layer)
    

</t>
<t tx="mhw.20190925103252.18">'''
Interpolate missing Z values along a 3D line

Adapted from @FelixIP
http://gis.stackexchange.com/a/147192/108

Tool assumes:

    a) 1st layer in Table of Content is TARGET polylineZ feature
    b) records in table sorted from upstream down
    c) selected features maintain direction, i.e. upstream line END point equal downstream line START point
    d) missing z value for vertex is 0
'''
import arcpy, traceback, os, sys, time
from arcpy import env
env.outputZFlag = "Enabled"
env.outputMFlag = "Enabled"

##sPath = r'd:\s\test.gdb'
##fcName = 'Flow3D'
mxdPath = r'D:\p\ytdemv3\work_105mn\Rivers.mxd'

</t>
<t tx="mhw.20190925103252.19">def showPyMessage():
    arcpy.AddMessage(str(time.ctime()) + " - " + message)

try:
    if not os.path.exists(mxdPath):
        mxd = arcpy.mapping.MapDocument("CURRENT")
    else:
        mxd = arcpy.mapping.MapDocument(mxdPath)

    destLR = arcpy.mapping.ListLayers(mxd)[0]
    dDest=arcpy.Describe(destLR)
    destProj=dDest.spatialReference
#  copy all lines to manageable list and merge
    g=arcpy.Geometry()
    geometryList=arcpy.CopyFeatures_management(destLR,g)
    nLines=len(geometryList)
    allPoints=geometryList[0].getPart(0)
    for i in range (1,nLines):
        part=geometryList[i].getPart(0)
        allPoints.extend(part)
    longLine=arcpy.Polyline(allPoints)

#  calc chainages
    dictFeatures,m = {},0
    for p in allPoints:
        dist=longLine.measureOnLine(p)
        dictFeatures[m]=(dist,p.Z)
        m+=1
#  find pairs
    first,nPoints,pairs=-1,len(allPoints),[]
    for i in range(nPoints):
        (d,z)=dictFeatures[i]
        if abs (z-0.0)&gt;0.001: first=i; break
    if first==-1 or first==(nPoints-1):
        arcpy.AddMessage("Not enough z info")
        sys.exit(0)
    pairs.append((first,d,z))
    while True:
        second =-1
        for i in range(first+1,nPoints):
            (d,z)=dictFeatures[i]
            if abs (z-0.0)&gt;0.001: second=i; break
        if second==-1:break
        first=second
        pairs.append((second,d,z))

# interpolate
    n=len(pairs)
    for j in range(1,n):
        first,d1,z1=pairs[j-1]
        second,d2,z2=pairs[j]
        dz=(z2-z1)/(d2-d1)
        for i in range(first+1,second):
            d,z=dictFeatures[i]
            z=z1 + dz*(d-d1)
            dictFeatures[i]=(d,z)
# update
    with arcpy.da.UpdateCursor(destLR,"Shape@") as cursor:
        aKey,m=0,0
        pz=arcpy.Point()
        newL=arcpy.Array()
        for row in cursor:
            shp=geometryList[m];m+=1
            part=shp.getPart(0)
            n=len(part)
            for i in range(n):
                p=part[i]
                d,z=dictFeatures[aKey]
                pz.X,pz.Y,pz.Z=p.X,p.Y,z
                newL.add(pz)
                aKey+=1
            newLine=arcpy.Polyline(newL,destProj,True)
            newL.removeAll()
            arcpy.AddMessage(newLine.length)
            cursor.updateRow((newLine,))
except:
    message = "\n*** PYTHON ERRORS *** "; showPyMessage()
    message = "Python Traceback Info: " + traceback.format_tb(sys.exc_info()[2])[0]; showPyMessage()
    message = "Python Error Info: " +  str(sys.exc_type)+ ": " + str(sys.exc_value) + "\n"; showPyMessage()

print arcpy.GetMessages()

</t>
<t tx="mhw.20190925103252.2">def get_sepchar(arg):
    '''Return decimal point separator to use'''
    default_seps = ['default python output', 'locale decimal point', '#']
    valid_seps = {'comma':',', 'period':'.', '$sep$':'$SEP$'}
    for i in default_seps:
        valid_seps[i] = 'locale default'

    arg = arg.lower()
    if arg not in valid_seps:
        raise Exception, msgUseValidDecimalPointSep + str(valid_seps.keys())

    if arg in default_seps:
        locale.setlocale(locale.LC_ALL, '')
        sepchar = locale.localeconv()['decimal_point']
    elif arg in valid_seps:
        sepchar = valid_seps[arg]
    ##elif arg == arg3poss[0]: sepchar = "" # is this ever valid? disabling for now.
    arcpy.AddMessage('Using "{0}" for decimal point separator'.format(sepchar))
    return sepchar

</t>
<t tx="mhw.20190925103252.20">def main():
    pass

</t>
<t tx="mhw.20190925103252.21">'''
Tool:   GPX to Features
Source: GPXtoFeaturesXY.py
Author: Esri

This tool takes a .GPX file (a common output from handheld GPS receivers). The tool will parse all points which particpate as either a waypoint (WPT) or inside a track as a track point (TRKPT). The output feature class will create fields for the shape, time, and elevation and description.

Required Arguments:
    Input GPX File:       path to GPX file
    Output Feature Class: path to featureclass which will be created


Modified by Matt.Wilkie@gov.yk.ca for Environment Yukon:

  + 2013-May-16: add X and Y as attribute fields in addition to geometry fields
  * 2014-May-22: sync with upstream 10.2.2 changes (more track info)
'''

# Imports
try:
  from xml.etree import cElementTree as ElementTree
except:
  from xml.etree import ElementTree

import arcpy
import arcpy.da as da
import os
import numpy


</t>
<t tx="mhw.20190925103252.22">def gpxToPoints(gpxfile, outFC):
    ''' This is called by the __main__ if run from a tool or at the command line
    '''

    # Set the tree to the input GPX file
    #
    tree = ElementTree.parse(gpxfile)

    global TOPOGRAFIX_NS
    TOPOGRAFIX_NS = ''
    TOPOGRAFIX_NS10 = './/{http://www.topografix.com/GPX/1/0}'
    TOPOGRAFIX_NS11 = './/{http://www.topografix.com/GPX/1/1}'

    badPt = 0

    # Inspection of the GPX file will yield and set the appropraite namespace. If 1.0 or 1.1
    # is not found, empty output will be generated
    #
    for TRKorWPT in ['wpt', 'trk', 'rte']:   
        if tree.findall(TOPOGRAFIX_NS10 + TRKorWPT):
            TOPOGRAFIX_NS = TOPOGRAFIX_NS10
        elif tree.findall(TOPOGRAFIX_NS11 + TRKorWPT):
            TOPOGRAFIX_NS = TOPOGRAFIX_NS11


    if TOPOGRAFIX_NS == '':
            arcpy.AddIDMessage("Warning", 1202)

    # Create the output feature class in WGS84
    #
    arcpy.CreateFeatureclass_management(os.path.dirname(outFC), os.path.basename(outFC), 'POINT', '', 'DISABLED', 'ENABLED', 4326)


    # Join fields to the feature class, using ExtendTable
    inarray = numpy.array([],
                      numpy.dtype([('intfield', numpy.int32),
                                   ('Name', '|S'),
                                   ('Descript', '|S'),
                                   ('Type', '|S'),
                                   ('Comment', '|S'),
                                   ('Symbol', '|S'),
                                   ('DateTimeS', '|S'),                                   
                                   ('Elevation', numpy.float),
                                   ('X', numpy.float),
                                   ('Y', numpy.float),
                                   ]))
    
    arcpy.da.ExtendTable(outFC, "OID@", inarray, "intfield")


    rowsDA = da.InsertCursor(outFC, ['Name', 'Descript', 'Type', 'Comment', 'Symbol', 'DateTimeS', 'Elevation', 'X', 'Y', 'SHAPE@X', 'SHAPE@Y', 'SHAPE@Z'])


    # Loop over each point in the tree and put the information inside a new row
    #
    for index, trkPoint in enumerate(GeneratePointFromXML(tree)):
        if trkPoint.asPoint() is not None:
            rowsDA.insertRow([trkPoint.name, trkPoint.desc, trkPoint.gpxtype, trkPoint.cmt, trkPoint.sym, 
                              trkPoint.t, trkPoint.z, trkPoint.x, trkPoint.y, trkPoint.x, trkPoint.y, trkPoint.z])
        else:
            badPt +=1


    if badPt &gt; 0:
        arcpy.AddIDMessage("WARNING", 1201, badPt, index + 1)

        
    if tree:
        del tree
    if rowsDA:
        del rowsDA        
       
        
    # Try to create a DateTime field of Date-type for non-shapefile output
    #
    if not outFC.lower().endswith(".shp"):
      try:
        arcpy.ConvertTimeField_management(outFC, 'DateTimeS', 'yyyy-MM-ddTHH:mm:ssZ', "DateTime")

      except:
        arcpy.AddIDMessage("WARNING", 1227)

        try:
          arcpy.DeleteField_management(outFC, "DateTime")
        except:
          pass



</t>
<t tx="mhw.20190925103252.23">class classGPXPoint(object):
    ''' Object to gather GPX information '''

    name = ''
    desc = ''
    cmt = ''
    sym = ''
    gpxtype = 'WPT'
    x = None
    y = None
    z = 0
    t = ''


    @others
</t>
<t tx="mhw.20190925103252.24">def __init__(self, node, gpxtype, name, desc, cmt, sym):
    self.name = name
    self.desc = desc
    self.cmt = cmt
    self.sym = sym
    self.gpxtype = gpxtype
    self.y = node.attrib.get('lat')
    self.x = node.attrib.get('lon')
    self.z = node.find(TOPOGRAFIX_NS + 'ele').text if node.find(TOPOGRAFIX_NS + 'ele') is not None else '0.0'
    self.t = node.find(TOPOGRAFIX_NS + 'time').text or '' if node.find(TOPOGRAFIX_NS + 'time') is not None else ''


</t>
<t tx="mhw.20190925103252.25">def asPoint(self):
    ''' Try to float X/Y. If conversion to a float fails, the X/Y is not valid and return NONE. '''

    try:
        self.x = float(self.x.replace(',','.'))
        self.y = float(self.y.replace(',','.')) 
        self.z = float(self.z.replace(',','.'))
        
        return self.x, self.y, self.z        

    except:
        return None



</t>
<t tx="mhw.20190925103252.26">def GeneratePointFromXML(tree):
    ''' 1) Inspect the tree for either TRK or WPT
           TRK's have a sub node of TRKPT which are examined.
        2) Yield the information back to insertcursor from the classGPXPoint object.    '''

    def _getNameDesc(node):
        name = node.find(TOPOGRAFIX_NS + 'name').text or '' if node.find(TOPOGRAFIX_NS + 'name') is not None else ''
        desc = node.find(TOPOGRAFIX_NS + 'desc').text or '' if node.find(TOPOGRAFIX_NS + 'desc') is not None else ''
        cmt = node.find(TOPOGRAFIX_NS + 'cmt').text or '' if node.find(TOPOGRAFIX_NS + 'cmt') is not None else ''
        sym = node.find(TOPOGRAFIX_NS + 'sym').text or '' if node.find(TOPOGRAFIX_NS + 'sym') is not None else ''
        return name, desc, cmt, sym

    for node in tree.findall(TOPOGRAFIX_NS + 'trk'):
        name, desc, cmt, sym = _getNameDesc(node)
        for node in node.findall(TOPOGRAFIX_NS + 'trkpt') :
            yield (classGPXPoint(node, 'TRKPT', name, desc, cmt, sym))
         
    for node in tree.findall(TOPOGRAFIX_NS + 'rte'):
        name, desc, cmt, sym = _getNameDesc(node)
        for node in node.findall(TOPOGRAFIX_NS + 'rtept') :
            yield (classGPXPoint(node, 'RTEPT', name, desc, cmt, sym))

    for node in tree.findall(TOPOGRAFIX_NS + 'wpt'):
        name, desc, cmt, sym = _getNameDesc(node)
        yield classGPXPoint(node, 'WPT', name, desc, cmt, sym)


</t>
<t tx="mhw.20190925103252.27">import arcpy

# Script arguments
Input_Features = arcpy.GetParameterAsText(0)
</t>
<t tx="mhw.20190925103252.28">'''
Tool Name:  Features to GPX
Source Name: FeaturesToGPX.py
Version: ArcGIS 10.1
Author: Esri
Contributors: Matt Wilkie,

Required Arguments:
         Input Features: path to layer or featureclass on disk
         Output Feature Class: path to GPX which will be created

Optional Arguments:
         Make Pretty: True/False. Create GPX files which are easier to read in a
         text editor.

Description:
         This tool takes input features (layers or featureclass) with either
         point or line geometry and converts into a .GPX file. Points and
         multipoint features are converted in to WPTs, lines are converted into
         TRKS. If the features conform to a known schema, the output GPX file
         will honor those fields. If DateTime field does not exist or cannot be
         parsed the "time" GPX element is set to system's epoch zero (usually
         1970-Jan-01).
Code:
         Upstream: https://github.com/arcpy/sample-gp-tools/tree/master/FeaturesToGPX
         Local: https://github.com/envygeo/arcplus/tree/master/ArcToolbox/Scripts
'''

try:
    from xml.etree import cElementTree as ET
except:
    from xml.etree import ElementTree as ET

import arcpy
import time
from datetime import datetime

gpx = ET.Element("gpx", xmlns="http://www.topografix.com/GPX/1/1",
              xalan="http://xml.apache.org/xalan",
              xsi="http://www.w3.org/2001/XMLSchema-instance",
              creator="Esri",
              version="1.1")


</t>
<t tx="mhw.20190925103252.29">def prettify(elem):
    """Return a pretty-printed XML string for the Element.
    This function not used, but can be used to create GPX files which are easier
    to read in a text editor.
    """
    from xml.dom import minidom
    rough_string = ET.tostring(elem, 'utf-8')
    reparsed = minidom.parseString(rough_string)
    return reparsed.toprettyxml(indent="  ")


</t>
<t tx="mhw.20190925103252.3">def validate_id(fieldname, desc):
    '''Validate 'fieldname' to use for UNGENERATE Feature ID label.

    '#' means use defined ObjectID or first field.

    field = string
    desc = feature class describe object

    Returns 'field' as string or False
    '''
    fields = [f.name.upper() for f in desc.fields]
    f = None
    if fieldname.upper() in fields:
       f = fieldname
    else:
        if fieldname == '#':
            try:
                f = desc.OIDFieldName
            except:
                f = fields[0]
    if not f:
        arcpy.AddError(msgFieldNotFound + '\n\t{0}'.format(', '.join(fields)))
    else:
        arcpy.AddMessage('Using "{0}" for FeatureID'.format(f))
    return f

</t>
<t tx="mhw.20190925103252.30">def featuresToGPX(inputFC, outGPX, pretty=False):
    ''' This is called by the __main__ if run from a tool or at the command line
    '''

    descInput = arcpy.Describe(inputFC)
    if descInput.spatialReference.factoryCode &lt;&gt; 4326:
        arcpy.AddWarning("Input data is not projected in WGS84, features were reprojected on the fly to create the GPX.")

    generatePointsFromFeatures(inputFC , descInput)

    # Write the output GPX file
    try:
        gpxFile = open(outGPX, "w")
        if pretty.lower() == "true":
            gpxFile.write(prettify(gpx))
        else:
            ET.ElementTree(gpx).write(gpxFile, encoding="UTF-8", xml_declaration=True)
    except TypeError:
        arcpy.AddError("Error serializing GPX into the file.")
    finally:
        gpxFile.close()


</t>
<t tx="mhw.20190925103252.31">def generatePointsFromFeatures(inputFC, descInput):

    def attHelper(row):
        # helper function to get/set field attributes for output gpx file

        pnt = row[1].getPart()
        valuesDict["PntX"] = str(pnt.X)
        valuesDict["PntY"] = str(pnt.Y)

        Z = pnt.Z if descInput.hasZ else None
        if Z or ("Elevation" in cursorFields):
            valuesDict["Elevation"] = str(Z) if Z else str(row[fieldNameDict["Elevation"]])  #is not None  &lt;- removed from the if/else
        else:
            valuesDict["Elevation"] = str(0)

        valuesDict["Name"] = row[fieldNameDict["Name"]] if "Name" in fields else " "
        valuesDict["Descript"] = row[fieldNameDict["Descript"]] if "Descript" in fields else " "

        # GPX 'time' value must not be empty. Attempt to read from attribute list
        # or set to Zero
        if "DateTime" in fields:
            row_time = row[fieldNameDict["DateTime"]]
            try:
                formatted_time = datetime.strftime(row_time, "%Y-%m-%dT%H:%M:%SZ")
                    # note reversed param order vs later time.strftime() is correct
            except Exception as e:
                arcpy.AddWarning("Failed to parse DateTime field. GPX times set to epoch zero")
                    # todo: emit only once instead of for each feature
                formatted_time = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime(0))
            valuesDict["DateTime"] = formatted_time
        else:
            arcpy.AddWarning("DateTime field not found, setting GPX times to epoch zero")
            formatted_time = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime(0))
            valuesDict["DateTime"] = formatted_time

        return
    #-------------end helper function-----------------


    def getValuesFromFC( inputFC, cursorFields ):

        previousPartNum = 0
        startTrack = True

        # Loop through all features and parts
        with arcpy.da.SearchCursor(inputFC, cursorFields, spatial_reference="4326", explode_to_points=True) as searchCur:
            for row in searchCur:
                if descInput.shapeType == "Polyline":
                    for part in row:
                        newPart = False
                        if not row[0] == previousPartNum or startTrack == True:
                            startTrack = False
                            newPart = True
                        previousPartNum = row[0]

                        attHelper(row)
                        yield "trk", newPart

                elif descInput.shapeType == "Multipoint" or descInput.shapeType == "Point":
                    #check to see if data was original GPX with "Type" of "TRKPT" or "WPT"
                    trkType = row[fieldNameDict["Type"]].upper() if "Type" in fields else None

                    attHelper(row)

                    if trkType == "TRKPT":
                        newPart = False
                        if previousPartNum == 0:
                            newPart = True
                            previousPartNum = 1

                        yield "trk", newPart

                    else:
                        yield "wpt", None

    #---------end get values function-------------


    # Get list of available fields
    fields = [f.name for f in arcpy.ListFields(inputFC)]
    valuesDict = {"Elevation": 0, "Name": "", "Descript": "", "DateTime": "", "Type": "", "PntX": 0, "PntY": 0}
    fieldNameDict = {"Elevation": 0, "Name": 1, "Descript": 2, "DateTime": 3, "Type": 4, "PntX": 5, "PntY": 6}

    cursorFields = ["OID@", "SHAPE@"]

    for key, item in valuesDict.items():
        if key in fields:
            fieldNameDict[key] = len(cursorFields)  #assign current index
            cursorFields.append(key)   #build up list of fields for cursor
        else:
            fieldNameDict[key] = None

    for index, gpxValues in enumerate(getValuesFromFC(inputFC, cursorFields)):

        if gpxValues[0] == "wpt":
            wpt = ET.SubElement(gpx, 'wpt', {'lon':valuesDict["PntX"], 'lat':valuesDict["PntY"]})
            wptEle = ET.SubElement(wpt, "ele")
            wptEle.text = valuesDict["Elevation"]
            wptTime = ET.SubElement(wpt, "time")
            wptTime.text = valuesDict["DateTime"]
            wptName = ET.SubElement(wpt, "name")
            wptName.text = valuesDict["Name"]
            wptDesc = ET.SubElement(wpt, "desc")
            wptDesc.text = valuesDict["Descript"]

        else:  #TRKS
            if gpxValues[1]:
                # Elements for the start of a new track
                trk = ET.SubElement(gpx, "trk")
                trkName = ET.SubElement(trk, "name")
                trkName.text = valuesDict["Name"]
                trkDesc = ET.SubElement(trk, "desc")
                trkDesc.text = valuesDict["Descript"]
                trkSeg = ET.SubElement(trk, "trkseg")

            trkPt = ET.SubElement(trkSeg, "trkpt", {'lon':valuesDict["PntX"], 'lat':valuesDict["PntY"]})
            trkPtEle = ET.SubElement(trkPt, "ele")
            trkPtEle.text = valuesDict["Elevation"]
            trkPtTime = ET.SubElement(trkPt, "time")
            trkPtTime.text = valuesDict["DateTime"]


</t>
<t tx="mhw.20190925103252.32">import zipfile
from arcpy import mapping
import arcpy
import os
from xml.dom.minidom import parse


</t>
<t tx="mhw.20190925103252.33">class LayerExtras(object):
    """ An object to hold attributes loaded from xml inside the msd."""

    name = ""
    symbologyFieldName = ""


</t>
<t tx="mhw.20190925103252.34">class MxdExtras(dict):
    """ Exposes extra MXD details by raiding an exported msd

        Treat this object as a dictionary with layer name as the key and a custom object
        with desired attributes as the value.
        You must have write access to MXD directory (creates temporary msd file).
        Only layers in the first dataframe are accessed.

    """    

    LYR_NAME_NODE = "Name"
    LYR_SYMBOL_NODE = "Symbolizer"
    LYR_FIELD_NODE = "Field"
    MSD_SUFFIX = "_MxdExtrasTemp.msd"
    MXD_SUFFIX = ".mxd"
    EXCLUDED_FILE_NAMES = ["DocumentInfo.xml", "layers/layers.xml"]
    mxdPath = ""

    @others
if __name__ == "__main__":

    mxdPath = os.path.join(os.environ["TEMP"],"ExportLayerSymbolDefinitions\Untitled.mxd")

    mxde = MxdExtras(mxdPath)

    for lyr in mxde.itervalues():
        print "Layer Name: ", lyr.name 
        print "Layer Symbology Field Name: ", lyr.symbologyFieldName

    print arcpy.GetMessages()
</t>
<t tx="mhw.20190925103252.35">def __init__(self, mxdPath):

    self.loadMxdPath(mxdPath)


</t>
<t tx="mhw.20190925103252.36">def loadMxdPath(self, mxdPath):
    """ Load mxd from file path """

    self.mxdPath = mxdPath.lower()
    mxd = mapping.MapDocument(self.mxdPath)

    msdPath = self.mxdPath.replace(self.MXD_SUFFIX, self.MSD_SUFFIX) 

    # Delete temporary msd if it exists
    if os.path.exists(msdPath):
        os.remove(msdPath)

    mapping.ConvertToMSD(mxd,msdPath)

    zz = zipfile.ZipFile(msdPath)

    for fileName in (fileName for fileName in zz.namelist() if not fileName in self.EXCLUDED_FILE_NAMES):
        dom = parse(zz.open(fileName))
        name, lyr = self.loadMsdLayerDom(dom)
        self[name] = lyr
    del zz
    os.remove(msdPath)

</t>
<t tx="mhw.20190925103252.37">def loadMsdLayerDom(self, dom):
    """ Load dom created from xml file inside the msd. """

    lyr = LayerExtras()  

    # Layer name
    try:
        lyr.name = dom.getElementsByTagName(self.LYR_NAME_NODE)[0].childNodes[0].nodeValue
    except IndexError:
        print 'oh oh, index error on "lyr.name"'

    # Symbology field name
    try:
        symbologyElement = dom.getElementsByTagName(self.LYR_SYMBOL_NODE)[0]
        lyr.symbologyFieldName = symbologyElement.getElementsByTagName(self.LYR_FIELD_NODE)[0].childNodes[0].nodeValue
    except IndexError:
        print 'oh oh, index error on "symbologyElement"'

    return lyr.name, lyr


\\-4.############
\\-4.# Test

</t>
<t tx="mhw.20190925103252.38">'''
Export a folder of maps to PDFs at their Map Document set sizes

Known to work ArcGIS 10.4.1 and Python 2.7.3
Adapted from work by @bteranUFA and @Guest
https://gis.stackexchange.com/questions/7147/how-to-batch-export-mxd-to-pdf-files

License X/MIT; (c) 2017 Environment Yukon, Matt Wilkie
'''

import os
import glob
import arcpy

# Folder to look for MXDs in
in_path = arcpy.GetParameterAsText(0)
# Where to save output documents
exportPath = arcpy.GetParameterAsText(1)
if exportPath == '':
    exportPath = in_path

overwrite = arcpy.GetParameter(2)
arcpy.AddMessage('Overwrite: %s' % overwrite)

# Set the PDF parameters as variables here:
data_frame = 'PAGE_LAYOUT'  # PAGE_LAYOUT or dataframe name
df_export_width = 1920      # ignored when using PAGE_LAYOUT
df_export_height = 1200
resolution = '300'
image_quality = 'BEST'      # FASTEST, FASTER, NORMAL, BETTER, BEST
colorspace = 'RGB'          # RGB, CMYK
compress_vectors = 'True'
image_compression = 'ADAPTIVE'      # ADAPTIVE, JPEG, DEFLATE, LZW, RLE, NONE
picture_symbol = 'VECTORIZE_BITMAP' # RASTERIZE_BITMAP, RASTERIZE_PICTURE, VECTORIZE_BITMAP
convert_markers = 'False'
embed_fonts = 'True'
layers_attributes = 'LAYERS_ONLY'   # LAYERS_ONLY, LAYERS_AND_ATTRIBUTES, NONE
georef_info = 'True'
jpeg_compression_quality = 85

maps = glob.glob(os.path.join(in_path, '*.mxd'))

</t>
<t tx="mhw.20190925103252.39">def exportmap(mxdPath, exportPath):
    fname = os.path.split(mxdPath)[1]                    # ''some_map.mxd' - discard prefix path elements
    basename = os.path.splitext(fname)[0]                # 'some_map' - discard extension
    newPDF = os.path.join(exportPath, basename + '.pdf') # 'Y:\output\some_map.pdf'
    open(newPDF, 'w').close()   # create empty marker file , for parallel script running.

    arcpy.AddMessage('Reading: ' + m)
    mxd = arcpy.mapping.MapDocument(m)
    arcpy.AddMessage('Writing: ' + newPDF)
    arcpy.mapping.ExportToPDF(mxd, newPDF, data_frame, df_export_width, df_export_height, resolution, image_quality,
                              colorspace, compress_vectors, image_compression, picture_symbol, convert_markers, embed_fonts,
                              layers_attributes, georef_info, jpeg_compression_quality)
    del mxd
    return

for m in maps:
    fname = os.path.split(m)[1]                          # ''some_map.mxd' - discard prefix path elements
    basename = os.path.splitext(fname)[0]                # 'some_map' - discard extension
    newPDF = os.path.join(exportPath, basename + '.pdf') # 'Y:\output\some_map.pdf'
    arcpy.AddMessage('--- %s' % os.path.split(m)[1])

    if os.path.exists(newPDF):
        if overwrite == True:
            exportmap(m, newPDF)
        else:
            arcpy.AddMessage('Skipping %s' % newPDF)


arcpy.GetMessages()
</t>
<t tx="mhw.20190925103252.4">'''
Tool:    Table to CSV
Source:  TableToCSV.py
Author:  Matt.Wilkie@gov.yk.ca
License: X/MIT, (c) 2014 Environment Yukon

Export a table to comma delimited text file (CSV)

Required Arguments:
    {path to}\input table
    {path to}\output.csv


Courtesy of Jason on "Export table to X,Y,Z ASCII file via arcpy"
@url http://gis.stackexchange.com/a/17934/108
'''
import arcpy
import csv

</t>
<t tx="mhw.20190925103252.40">"""
Tool name: Export GDB Domains to Tables
Source: export_gdb_domains.py
Author: Matt Wilkie (Environment Yukon)
License: X/MIT open source

Export all coded value domains in a geodatabase to tables in that gdb
    http://gis.stackexchange.com/questions/26215
"""
import os, sys
import arcpy

gdb = arcpy.GetParameterAsText(0)
xls = str.title(arcpy.GetParameterAsText(1))
    # True or False
arcpy.env.overwriteOutput = str.title(arcpy.GetParameterAsText(2))
    # True or False

if not os.path.exists(gdb):
    print('Usage:\n\n   python export_gdb_domains.py [input geodatabase] {write_xls} {overwrite}')
    print('   python export_gdb_domains.py [input geodatabase] true false')
    sys.exit()


</t>
<t tx="mhw.20190925103252.41">def export_domains(domains):
    for domain in domains:
        arcpy.AddMessage('Exporting %s CV to table in %s' % (domain.name, gdb))
        table = os.path.join(gdb, domain.name)
        arcpy.DomainToTable_management(gdb, domain.name, table,
            'field','descript', '#')
        if xls:
            os.chdir(gdb)
            os.chdir('..')
            xlsfile = '%s_%s.xls' % (os.path.join(os.path.basename(gdb)),domain.name)
            arcpy.AddMessage('Exporting %s CV to table in %s' % (domain.name, xlsfile))
            arcpy.TableToExcel_conversion(table, xlsfile)


</t>
<t tx="mhw.20190925103252.42">"""
Tool name: Import Excel Sheets To Tables
Source: ExcelSheetsToTables.py
Author: Esri, Matt Wilkie

Convert all sheets in a Microsoft Excel (xls or xlsx) file to geodatabase, dbf or INFO tables.

Adapted from Excel To Table (Conversion)
    http://resources.arcgis.com/en/help/main/10.2/index.html#//001200000055000000
"""
import os
import xlrd
import arcpy

import os
import xlrd
import arcpy

</t>
<t tx="mhw.20190925103252.43">def importallsheets(in_excel, table_prefix, out_gdb):
    workbook = xlrd.open_workbook(in_excel)
    sheets = [sheet.name for sheet in workbook.sheets()]

    arcpy.AddMessage('{} sheets found: {}'.format(len(sheets), ','.join(sheets)))
    for sheet in sheets:
        out_table = os.path.join(
            out_gdb,
            arcpy.ValidateTableName(
                "{0}_{1}".format(table_prefix, sheet),
                out_gdb))

        arcpy.AddMessage('Converting {} to {}'.format(sheet, out_table))

        # Perform the conversion
        arcpy.ExcelToTable_conversion(in_excel, out_table, sheet)

</t>
<t tx="mhw.20190925103252.44">'''Clip all layers in the map to the specified polygon.
Adapted from Alex Tereshenkov, http://gis.stackexchange.com/a/111712/108
'''
import os
import arcpy
arcpy.env.overwriteOutput = True

mxd = arcpy.GetParameterAsText(0)
clip_layer = arcpy.GetParameterAsText(1)
out_gdb = arcpy.GetParameterAsText(2)

</t>
<t tx="mhw.20190925103252.45">'''
Tool:    Change Datasource Paths
Source:  change_datasource_paths.py
Author:  Matt.Wilkie@gov.yk.ca
License: X/MIT, (c) 2011 Environment Yukon

When data has moved to a different workspace AND feature dataset the regular
`findAndReplaceWorkspacePath` does not work. This script rectifies that.


Required Arguments:
    - layer file to re-path
    - new path to workspace containing the feature class
    - where to save the layer files

More information:
http://gis.stackexchange.com/questions/6884/change-data-source-path-in-lyr-files-in-arcgis-10
'''
import arcpy, os

# layer file to re-path
fname = arcpy.GetParameterAsText(0)
# new path to workspace containing the feature class
target_wspace = arcpy.GetParameterAsText(1)
# where to save the layer files
savedir = arcpy.GetParameterAsText(2)

lyr = arcpy.mapping.Layer(fname)

fixed_fname = os.path.join(savedir, lyr.longName)

print '\nOld layer properties (%s)' % (fname)
print 'workspace:\t', lyr.workspacePath
print 'full path:\t', lyr.dataSource

try:
    lyr.replaceDataSource(target_wspace, 'FILEGDB_WORKSPACE', lyr.datasetName, True)
    lyr.saveACopy(fixed_fname)
except:
    print arcpy.GetMessages()

print '\nNew layer properties (%s)' % (fixed_fname)
print 'workspace:\t', lyr.workspacePath
print 'full path:\t', lyr.dataSource

del lyr
</t>
<t tx="mhw.20190925103252.46">import arcpy

gdb = r'd:\s\test.gdb'
fc_stream = 'test_vtx_wtc'
fc_contour = 'test_vtx_ctr'
fc_result = 'test_result'

arcpy.env.workspace = gdb
geometries = arcpy.CopyFeatures_management(fc_stream, arcpy.Geometry())


</t>
<t tx="mhw.20190925103252.47">def read_stream(fc_stream, fc_contour):
    g_ctr = arcpy.CopyFeatures_management(fc_contour, arcpy.Geometry())
    g = g_ctr[0]

    for row in arcpy.da.SearchCursor(fc_stream, ["OID@", "SHAPE@"]):
        print("Feature {0}:".format(row[0]))
        partnum = 0
        for part in row[1]:
            print("Part {0}:".format(partnum))

            # Step through each vertex in the feature
            for pnt in part:
                if pnt:
                    print("{}, {}, {}".format(pnt.X, pnt.Y, pnt.Z))
                    print pnt.touches(g)
                else:
                    # If pnt is None, this represents an interior ring
                    print("Interior Ring:")
            partnum += 1


</t>
<t tx="mhw.20190925103252.48">def thing(fc_stream, fc_contour):
    g_wtc = arcpy.CopyFeatures_management(fc_stream, arcpy.Geometry())
    g_ctr = arcpy.CopyFeatures_management(fc_contour, arcpy.Geometry())

    for g in g_ctr:
        print g.firstPoint, g.lastPoint

    for v in g_wtc[0]:
        print v.X, v.Y, v.Z

##    print g_wtc.JSON






##    arcpy.CreateFeatureclass_management(gdb, fc_result, "POLYLINE", fc_stream)
##    cur = arcpy.da.InsertCursor(fc_result, ["SHAPE@"])
##    array = arcpy.Array()
##    ID = -1
##    for coords in


</t>
<t tx="mhw.20190925103252.49">def main():
    pass

</t>
<t tx="mhw.20190925103252.5">def table2csv(table, outfile):
  #--first lets make a list of all of the fields in the table
  fields = arcpy.ListFields(table)
  field_names = [field.name for field in fields]

  with open(outfile,'wb') as f:
      dw = csv.DictWriter(f,field_names)
      #--write all field names to the output file
      dw.writeheader()

      #--now we make the search cursor that will iterate through the rows of the table
      with arcpy.da.SearchCursor(table,field_names) as cursor:
          for row in cursor:
              dw.writerow(dict(zip(field_names,row)))


</t>
<t tx="mhw.20190925103252.6">''' Set legend symbology from a raster attribute table

 Sources:
    - http://desktop.arcgis.com/en/arcmap/latest/analyze/arcpy-mapping/uniquevaluessymbology-class.htm
 '''
import arcpy
mxd = arcpy.mapping.MapDocument("current")
lyr = arcpy.mapping.ListLayers(mxd, "Population")[0]
arcpy.SelectLayerByAttribute_management(lyr, "NEW_SELECTION", "\"POP2000\" &gt; 20000000")
stateList = []
rows = arcpy.da.SearchCursor(lyr, ["STATE_NAME"])
for row in rows:
  stateList.append(row[0])

</t>
<t tx="mhw.20190925103252.7">from osgeo import ogr, sys

</t>
<t tx="mhw.20190925103252.8">'''
Set description property of Unique Value legend items from a lookup table. Enables having a legend with lengthy descriptions as well as the record values.

Example:

[SB]      Black Spruce	Black spruce diagnostic and dominant in sparse tree and 
          shrub overstory; shrub birch, willow and low ericaceous shrubs also common. 
          Extensive moss groundcover, Sphagnum present. Established on permafrost and 
          poorly drained sites at lower elevations.
      
[D/G/Li]  Mat vegetation dominated by Dryas and diverse lichens; graminoids 
          significant but sparse. Ericaceous groundshrubs and prostate willows 
          common. Typical on exposed sites at higher elevations.


Adapted from 
http://gis.stackexchange.com/questions/102956/setting-symbol-descript_table-of-arcmap-layout-legends-from-table
'''
import arcpy

# name and path of the lookup table
lookup_table = r"T:\ENV.344\SDR\ENV344.gdb\vegMajorComm_Lookup"

# change these to match the relevant field names in the lookup table
code = 'VegCode'
description = 'Description'

map_name = r"..\map\test_map.mxd"           
layer_name = "Vegetation Communities"
output_map = r"..\map\test_map_descrip.mxd"

## --- shouldn't need to change anything below here ---

mxd = arcpy.mapping.MapDocument(map_name)
lyr = arcpy.mapping.ListLayers(mxd, layer_name)[0]

# build the descriptions dictionary
descriptions = {}
rows = arcpy.SearchCursor(lookup_table)
for item in rows:
    #print item.getValue(code), item.getValue(description)
    descriptions[item.getValue(code)] = item.getValue('MajorCommunity') + item.getValue(description)

print descriptions

# lyr.symbology requires the classValues and classDescriptions to have
# same number of rows and be in same order. So extract only matching 
# elements from the description dictionary
desclist = []
</t>
<t tx="mhw.20190925103252.9">"""
Name:        sdeconn.py
Description: Utility functions for sde connections
Author:      blord-castillo (http://gis.stackexchange.com/users/3386/blord-castillo)

Do on the fly connections in python using Sql Server direct connect only.
Eliminates the problem of database connection files being inconsistent from
machine to machine or user profile to user profile.

Usage:

    import arcpy, sdeconn
    myconnect1 = sdeconn.connect("database1", "server")
    myconnect2 = sdeconn.connect("database2", "server")


Source:
    http://gis.stackexchange.com/questions/16859/define-workspace-for-sde-connection-in-python

"""

# Import system modules
import arcpy, os, sys

</t>
<t tx="mhw.20190925103922.1">@others
if group_layers:
    arcpy.AddMessage('\n--- Skipped group layers:\n')
    for s in group_layers:
        arcpy.AddMessage(s)
if problem_layers:
    arcpy.AddMessage('\n--- Unknown problem layers:\n')
    for s in problem_layers:
        arcpy.AddMessage(s)


## --- Notes ---
# "Main" should be wrapped in one or more functions and whole thing run
# from `if __name__ == '__main__':` construct
# That will simplify the While and Break loop exits as well just being
# better code.
#
# Would be nice to handle group layers too.
# and of course add to a Toolbox for regular users.
@language python
@tabwidth -4
</t>
<t tx="mhw.20190925103950.1">'''Create personal layer files for all .lyr files from a source folder
with a UNC path.

Designed for use with a password protected geodatabase. Afterwards,
using the personal layer files will skip authentication prompt.

Usage:

    python save-layers-my-credentials.py "[in path]" "[sde file]" "[out path]"

Inputs:
    - UNC path with layer files
        (\\CSWPROD\Layerfiles)
    - SDE Credentials file
        ("%APPDATA%\Esri\Desktop10.6\ArcCatalog\Connection to CSWPROD.sde")
    - Folder to store the result .lyr files
        (C:\users\jonahwhale\Documents\ArcGIS\Layers)

Known Limitations:
    - doesn't handle group layers


Tested with ArcMap 10.6 and Python 2.7 on Win10 x64.

Matt.Wilkie@gov.yk.ca, 2019-07-16
License: X/MIT Open Source
(c) 2019 Environment Yukon
'''
import os
import sys
import glob
import fnmatch
import arcpy

inpath = arcpy.GetParameterAsText(0)
sdefile  = arcpy.GetParameterAsText(1)
docfolder = arcpy.GetParameterAsText(2)

# hardcoded paths if literal `**DEV` is first parameter
if inpath == '**DEV':
    inpath = r'\\cswprod\Layerfiles'
    docfolder = r'C:\Users\mhwilkie\Documents\ArcGIS\Layers'
    sdefile = r"C:\Users\mhwilkie\AppData\Roaming\ESRI\Desktop10.6\ArcCatalog\Connection to cswprod.sde"

if not os.path.exists(inpath):
    msg = "*** Input path not found: '{}' ".format(inpath)
    arcpy.AddMessage(msg)
    print('\nUsage: {} "[in UNC path]" "[sde file]" "[out path]"\n'.format(sys.argv[0]))
    sys.exit()

if not os.path.exists(sdefile):
    msg = "*** SDE file not found: '{}'".format(sdefile)
    arcpy.AddMessage(msg)
    sys.exit()

if not os.path.exists(docfolder):
    os.makedirs(docfolder)

</t>
<t tx="mhw.20190925103950.2">def get_filenames(inpath, pattern='*.lyr'):
    matches = []
    for root, dirnames, filenames in os.walk(inpath):
        for filename in fnmatch.filter(filenames, pattern):
            matches.append(os.path.join(root, filename))
    return matches

layers = get_filenames(inpath, pattern='*.lyr')

arcpy.AddMessage('IN: {}'.format(inpath))
arcpy.AddMessage('OUT: {}'.format(docfolder))

# Skipped layers
group_layers = []
problem_layers = []

## Main
for L in layers:
    while L:
        lyr = arcpy.mapping.Layer(L)

        if lyr.isGroupLayer:
            group_layers.append(L)
            break

        server = lyr.serviceProperties['Server']

        # Parse in path and filename to remove \\server\share
        # and identify Category and actual layerfile name
        #
        # in = '\\\\cswprod\\Layerfiles\\Administrative Boundaries\\Game Management Areas - 250k.lyr'
        # category = 'Administrative Boundaries'
        # lyrfile = 'Game Management Areas - 250k.lyr'
        x = os.path.splitunc(L)[1]
        x = x.lstrip('\\')
        category, lyrfile = os.path.split(x)
        arcpy.AddMessage('Processing: {}\{}'.format(category, lyrfile))

        # ...\Docs\ArcGIS\Layers\{server}\{category}\{layer.lyr}
        outfolder = os.path.join(docfolder, server, category)
        if not os.path.exists(outfolder):
            os.makedirs(outfolder)

        try:
            lyr.findAndReplaceWorkspacePath('', sdefile, validate=False)

            #full path to output .lyr file
            fname = os.path.join(
                    outfolder,
                    lyr.name)

            lyr.saveACopy(fname)
        except ValueError as e:
            arcpy.AddMessage('*** {}\n\t{}'.format(lyr.name, e))
            problem_layers.append([lyr.name, e])

        del lyr # release from memory
        break


# Report skippped
</t>
</tnodes>
</leo_file>
